{"version": 2, "width": 160, "height": 40, "timestamp": 1763117632, "env": {"SHELL": "/bin/bash", "TERM": "tmux-256color"}}
[0.003355, "o", "\u001b[?2004hroot@61da2653ee41:/app# "]
[2.995281, "i", "clear\r"]
[2.995562, "o", "clear\r\n\u001b[?2004l\r"]
[2.996516, "o", "\u001b[H\u001b[J\u001b[3J"]
[2.996665, "o", "\u001b[?2004hroot@61da2653ee41:/app# "]
[34.092385, "i", "cat > extract.js << 'EOF'\nconst fs = require('fs');\nconst path = process.argv[2];\n\nif (!path) {\n  console.error('Usage: node extract.js <binary-path>');\n  process.exit(1);\n}\n\nconst buffer = fs.readFileSync(path);\nconst result = {};\n\n// ELF header parsing\nif (buffer[0] !== 0x7f || buffer[1] !== 0x45 || buffer[2] !== 0x4c || buffer[3] !== 0x46) {\n  console.error('Not a valid ELF file');\n  process.exit(1);\n}\n\nconst is64bit = buffer[4] === 2;\nconst isLittleEndian = buffer[5] === 1;\n\nfunction readUInt32(offset) {\n  return buffer.readUInt32LE(offset);\n}\n\nfunction readUInt64(offset) {\n  return Number(buffer.readBigUInt64LE(offset));\n}\n\nlet e_shoff, e_shentsize, e_shnum, e_shstrndx;\n\nif (is64bit) {\n  e_shoff = readUInt64(0x28);\n  e_shentsize = buffer.readUInt16LE(0x3a);\n  e_shnum = buffer.readUInt16LE(0x3c);\n  e_shstrndx = buffer.readUInt16LE(0x3e);\n} else {\n  e_shoff = readUInt32(0x20);\n  e_shentsize = buffer.readUInt16LE(0x2e);\n  e_shnum = buffer.readUInt16LE(0x30);\n  e_shstrndx = buffer.readUInt16LE(0x32);\n}\n\n// Read section headers\nconst sections = [];\nfor (let i = 0; i < e_shnum; i++) {\n  const offset = e_shoff + i * e_shentsize;\n  let section;\n  \n  if (is64bit) {\n    section = {\n      sh_name: readUInt32(offset),\n      sh_type: readUInt32(offset + 4),\n      sh_flags: readUInt64(offset + 8),\n      sh_addr: readUInt64(offset + 16),\n      sh_offset: readUInt64(offset + 24),\n      sh_size: readUInt64(offset + 32)\n    };\n  } else {\n    section = {\n      sh_name: readUInt32(offset),\n      sh_type: readUInt32(offset + 4),\n      sh_flags: readUInt32(offset + 8),\n      sh_addr: readUInt32(offset + 12),\n      sh_offset: readUInt32(offset + 16),\n      sh_size: readUInt32(offset + 20)\n    };\n  }\n  sections.push(section);\n}\n\n// Extract data from loadable sections with data\nfor (const section of sections) {\n  // SHT_PROGBITS = 1, check if allocated (SHF_ALLOC = 0x2)\n  if (section.sh_type === 1 && (section.sh_flags & 0x2) && section.sh_size > 0) {\n    const addr = section.sh_addr;\n    const offset = section.sh_offset;\n    const size = section.sh_size;\n    \n    // Extract 4-byte integers from this section\n    for (let i = 0; i + 4 <= size; i += 4) {\n      const memAddr = addr + i;\n      const value = buffer.readInt32LE(offset + i);\n      result[memAddr] = value;\n    }\n  }\n}\n\nconsole.log(JSON.stringify(result));\nEOF; tmux wait -S done\r"]
[34.092723, "o", "cat > extract.js << 'EOF'\r\n\u001b[?2004l\r\u001b[?2004h"]
[34.092977, "o", "> const fs = require('fs');\r\n\u001b[?2004l\r\u001b[?2004h> const path = process.argv[2];"]
[34.093071, "o", "\r\n"]
[34.093087, "o", "\u001b[?2004l\r\u001b[?2004h> \r\n"]
[34.093111, "o", "\u001b[?2004l\r"]
[34.093179, "o", "\u001b[?2004h"]
[34.093226, "o", "> if (!path) {\r\n\u001b[?2004l\r"]
[34.093351, "o", "\u001b[?2004h>   console.error('Usage: node extract.js <binary-path>');"]
[34.093406, "o", "\r\n"]
[34.093446, "o", "\u001b[?2004l\r"]
[34.093514, "o", "\u001b[?2004h> "]
[34.093522, "o", "  process.exit(1);"]
[34.093597, "o", "\r\n\u001b[?2004l\r\u001b[?2004h> }\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> "]
[34.093695, "o", "const buffer = fs.readFileSync(path);\r\n"]
[34.093761, "o", "\u001b[?2004l\r\u001b[?2004h"]
[34.093773, "o", "> const result = {};"]
[34.093837, "o", "\r\n\u001b[?2004l\r"]
[34.093894, "o", "\u001b[?2004h"]
[34.09393, "o", "> "]
[34.09398, "o", "\r\n\u001b[?2004l\r\u001b[?2004h"]
[34.094008, "o", "> // ELF header parsing"]
[34.094174, "o", "\r\n\u001b[?2004l\r\u001b[?2004h> if (buffer[0] !== 0x7f || buffer[1] !== 0x45 || buffer[2] !== 0x4c || buffer[3] !== 0x46) {"]
[34.094243, "o", "\r\n"]
[34.094252, "o", "\u001b[?2004l\r\u001b[?2004h"]
[34.094275, "o", "> "]
[34.094336, "o", "  console.error('Not a valid ELF file');"]
[34.094515, "o", "\r\n\u001b[?2004l\r\u001b[?2004h>   process.exit(1);"]
[34.094544, "o", "\r\n"]
[34.094562, "o", "\u001b[?2004l\r\u001b[?2004h"]
[34.094741, "o", "> }\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> "]
[34.094758, "o", "const is64bit = buffer[4] === 2;"]
[34.09492, "o", "\r\n\u001b[?2004l\r\u001b[?2004h> const isLittleEndian = buffer[5] === 1;"]
[34.095042, "o", "\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> function readUInt32(offset) {\r\n\u001b[?2004l\r\u001b[?2004h"]
[34.09519, "o", ">   return buffer.readUInt32LE(offset);\r\n\u001b[?2004l\r\u001b[?2004h> }\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r"]
[34.095726, "o", "\u001b[?2004h> function readUInt64(offset) {\r\n\u001b[?2004l\r\u001b[?2004h>   return Number(buffer.readBigUInt64LE(offset));\r\n\u001b[?2004l\r\u001b[?2004h> }\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> let e_shoff, e_shentsize, e_shnum, e_shstrndx;\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> if (is64bit) {\r\n\u001b[?2004l\r\u001b[?2004h>   e_shoff = readUInt64(0x28);\r\n\u001b[?2004l\r\u001b[?2004h>   e_shentsize = buffer.readUInt16LE(0x3a);\r\n\u001b[?2004l\r\u001b[?2004h>   e_shnum = buffer.readUInt16LE(0x3c);\r\n\u001b[?2004l\r\u001b[?2004h>   e_shstrndx = buffer.readUInt16LE(0x3e);\r\n\u001b[?2004l\r\u001b[?2004h> } else {\r\n\u001b[?2004l\r\u001b[?2004h>   e_shoff = readUInt32(0x20);\r\n\u001b[?2004l\r\u001b[?2004h>   e_shentsize = buffer.readUInt16LE(0x2e);\r\n\u001b[?2004l\r\u001b[?2004h> "]
[34.097398, "o", "  e_shnum = buffer.readUInt16LE(0x30);\r\n\u001b[?2004l\r\u001b[?2004h>   e_shstrndx = buffer.readUInt16LE(0x32);\r\n\u001b[?2004l\r\u001b[?2004h> }\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> // Read section headers\r\n\u001b[?2004l\r\u001b[?2004h> const sections = [];\r\n\u001b[?2004l\r\u001b[?2004h> for (let i = 0; i < e_shnum; i++) {\r\n\u001b[?2004l\r\u001b[?2004h>   const offset = e_shoff + i * e_shentsize;\r\n\u001b[?2004l\r\u001b[?2004h>   let section;\r\n\u001b[?2004l\r\u001b[?2004h>   \r\n\u001b[?2004l\r\u001b[?2004h>   if (is64bit) {\r\n\u001b[?2004l\r\u001b[?2004h>     section = {\r\n\u001b[?2004l\r\u001b[?2004h>       sh_name: readUInt32(offset),\r\n\u001b[?2004l\r\u001b[?2004h>       sh_type: readUInt32(offset + 4),\r\n\u001b[?2004l\r\u001b[?2004h>       sh_flags: readUInt64(offset + 8),\r\n\u001b[?2004l\r\u001b[?2004h>       sh_addr: readUInt64(offset + 16),\r\n\u001b[?2004l\r\u001b[?2004h>       sh_offset: readUInt64(offset + 24),\r\n\u001b[?2004l\r\u001b[?2004h>       sh_size: readUInt64(offset + 32)\r\n\u001b[?2004l\r\u001b[?2004h>     };\r\n\u001b[?2004l\r\u001b[?2004h>   } else {\r\n\u001b[?2004l\r\u001b[?2004h>     section = {\r\n\u001b[?2004l\r\u001b[?2004h>       sh_name: readUInt32(offset),\r\n\u001b[?2004l\r\u001b[?2004h>       sh_type: readUInt32(offset + 4),\r\n\u001b[?2004l\r\u001b[?2004h>       sh_flags: readUInt32(offset + 8),\r\n\u001b[?2004l\r\u001b[?2004h>       sh_addr: readUInt32(offset + 12),\r\n\u001b[?2004l\r\u001b[?2004h>       sh_offset: readUInt32(offset + 16),\r\n\u001b[?2004l\r\u001b[?2004h>       sh_size: readUInt32(offset + 20)\r\n\u001b[?2004l\r\u001b[?2004h>     };\r\n\u001b[?2004l\r\u001b[?2004h>   }\r\n\u001b[?2004l\r\u001b[?2004h>   sections.push(section);\r\n\u001b[?2004l\r\u001b[?2004h> }\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> // Extract data from loadable sections with data\r\n\u001b[?2004l\r\u001b[?2004h> for (const section of sections) {\r\n\u001b[?2004l\r\u001b[?2004h>   // SHT_PROGBITS = 1, check if allocated (SHF_ALLOC = 0x2)\r\n\u001b[?2004l\r\u001b[?2004h>   if (section.sh_type === 1 && (section.sh_flags & 0x2) && section.sh_size > 0) {\r\n\u001b[?2004l\r\u001b[?2004h>     const addr = section.sh_addr;\r\n\u001b[?2004l\r\u001b[?2004h>     const offset = section.sh_offset;\r\n\u001b[?2004l\r\u001b[?2004h>     const size = section.sh_size;\r\n\u001b[?2004l\r\u001b[?2004h>     \r\n\u001b[?2004l\r\u001b[?2004h>     // Extract 4-byte integers from this section\r\n\u001b[?2004l\r\u001b[?2004h>     for (let i = 0; i + 4 <= size; i += 4) {\r\n\u001b[?2004l\r\u001b[?2004h>       const memAddr = addr + i;\r\n\u001b[?2004l\r\u001b[?2004h>       const value = buffer.readInt32LE(offset + i);\r\n\u001b[?2004l\r\u001b[?2004h>       result[memAddr] = value;\r\n\u001b[?2004l\r\u001b[?2004h>     }\r\n\u001b[?2004l\r\u001b[?2004h>   }\r\n\u001b[?2004l\r\u001b[?2004h> }\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> console.log(JSON.stringify(result));\r\n\u001b[?2004l\r\u001b[?2004h> EOF; tmux wait -S done\r\n\u001b[?2004l\r\u001b[?2004h> "]
[222.389035, "i", "\u0004"]
[222.389577, "o", "\u001b[?2004l\r\r\nbash: warning: here-document at line 2 delimited by end-of-file (wanted `EOF')\r\n"]
[222.389933, "o", "\u001b[?2004h"]
[222.390031, "o", "root@61da2653ee41:/app# "]
