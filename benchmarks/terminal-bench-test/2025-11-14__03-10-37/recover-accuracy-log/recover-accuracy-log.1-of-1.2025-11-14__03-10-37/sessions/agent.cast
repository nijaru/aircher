{"version": 2, "width": 160, "height": 40, "timestamp": 1763118695, "env": {"SHELL": "/bin/bash", "TERM": "tmux-256color"}}
[0.001279, "o", "\u001b[?2004hroot@7aa0ba912b35:/app# "]
[2.997427, "i", "clear\r"]
[2.997889, "o", "clear\r\n\u001b[?2004l\r"]
[2.998526, "o", "\u001b[H\u001b[J\u001b[3J"]
[2.998681, "o", "\u001b[?2004hroot@7aa0ba912b35:/app# "]
[39.746949, "i", "mkdir -p /app/recovered_logs; tmux wait -S done\r"]
[39.747067, "o", "mkdir -p /app/recovered_logs; tmux wait -S done\r\n\u001b[?2004l\r"]
[39.749703, "o", "\u001b[?2004hroot@7aa0ba912b35:/app# "]
[39.799205, "i", "python3 << 'EOF'\nimport json\nimport re\nfrom collections import defaultdict\nfrom decimal import Decimal, ROUND_HALF_UP\n\n# Read logs\nwith open('/app/raw_logs/generator.log') as f:\n    gen_events = [json.loads(line) for line in f]\n\nwith open('/app/raw_logs/judge.log') as f:\n    judge_events = [json.loads(line) for line in f]\n\n# Group by question_id and sort by timestamp\ngen_by_qid = defaultdict(list)\nfor event in gen_events:\n    gen_by_qid[event['question_id']].append(event)\n\njudge_by_qid = defaultdict(list)\nfor event in judge_events:\n    judge_by_qid[event['question_id']].append(event)\n\n# Sort each question's events by timestamp\nfor qid in gen_by_qid:\n    gen_by_qid[qid].sort(key=lambda x: x['timestamp'])\n\nfor qid in judge_by_qid:\n    judge_by_qid[qid].sort(key=lambda x: x['timestamp'])\n\n# Assign to runs (earliest=run1, middle=run2, latest=run3)\nruns = {1: {'generator': [], 'judge': []}, 2: {'generator': [], 'judge': []}, 3: {'generator': [], 'judge': []}}\n\nfor qid in gen_by_qid:\n    events = gen_by_qid[qid]\n  "]
[39.799355, "o", "python3 << 'EOF'"]
[39.799469, "i", "  runs[1]['generator'].append(events[0])\n    runs[2]['generator'].append(events[1])\n    runs[3]['generator'].append(events[2])\n\nfor qid in judge_by_qid:\n    events = judge_by_qid[qid]\n    runs[1]['judge'].append(events[0])\n    runs[2]['judge'].append(events[1])\n    runs[3]['judge'].append(events[2])\n\n# Sort each run by timestamp and write to files\nfor run_id in [1, 2, 3]:\n    runs[run_id]['generator'].sort(key=lambda x: x['timestamp'])\n    runs[run_id]['judge'].sort(key=lambda x: x['timestamp'])\n    \n    with open(f'/app/recovered_logs/run_{run_id}_generator.jsonl', 'w') as f:\n        for event in runs[run_id]['generator']:\n            f.write(json.dumps({'timestamp': event['timestamp'], 'question_id': event['question_id'], 'prediction': event['prediction']}, separators=(',', ':')) + '\\n')\n    \n    with open(f'/app/recovered_logs/run_{run_id}_judge.jsonl', 'w') as f:\n        for event in runs[run_id]['judge']:\n            f.write(json.dumps({'timestamp': event['timestamp'], 'question_id': event['question_id']"]
[39.799534, "o", "\r\n\u001b[?2004l\r\u001b[?2004h> import json\r\n\u001b[?2004l\r\u001b[?2004h> import re"]
[39.799542, "i", ", 'target': event['target']}, separators=(',', ':')) + '\\n')\n\n# Check if value is an error\ndef is_error(value):\n    value_lower = value.lower()\n    return 'quota exceeds' in value_lower or 'api error' in value_lower or 'timeout' in value_lower\n\n# Compute accuracy for each run\nresults = []\nfor run_id in [1, 2, 3]:\n    gen_map = {e['question_id']: e['prediction'] for e in runs[run_id]['generator']}\n    judge_map = {e['question_id']: e['target'] for e in runs[run_id]['judge']}\n    \n    correct = 0\n    total = 0\n    \n    for qid in gen_map:\n        if qid in judge_map:\n            pred = gen_map[qid]\n            tgt = judge_map[qid]\n            \n            # Skip if either is an error\n            if is_error(pred) or is_error(tgt):\n                continue\n            \n            total += 1\n            if pred == tgt:\n                correct += 1\n    \n    if total == 0:\n        accuracy = None\n    else:\n        # Round half up to 2 decimals\n        acc_decimal = Decimal(correct) / Decimal(total)\n        accurac"]
[39.799549, "i", "y = float(acc_decimal.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))\n    \n    results.append({\n        'run_index': run_id,\n        'correct': correct,\n        'total': total,\n        'accuracy': accuracy\n    })\n\n# Write results\nwith open('/app/recovered_logs/results.json', 'w') as f:\n    json.dump({'runs': results}, f)\n\nEOF; tmux wait -S done\r"]
[39.799939, "o", "\r\n\u001b[?2004l\r\u001b[?2004h> from collections import defaultdict\r\n\u001b[?2004l\r\u001b[?2004h> from decimal import Decimal, ROUND_HALF_UP\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> # Read logs\r\n\u001b[?2004l\r\u001b[?2004h> with open('/app/raw_logs/generator.log') as f:\r\n\u001b[?2004l\r\u001b[?2004h>     gen_events = [json.loads(line) for line in f]\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r"]
[39.799953, "o", "\u001b[?2004h> "]
[39.800054, "o", "with open('/app/raw_logs/judge.log') as f:\r\n\u001b[?2004l\r\u001b[?2004h>     judge_events = [json.loads(line) for line in f]\r\n\u001b[?2004l\r\u001b[?2004h"]
[39.800068, "o", "> \r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.80012, "o", "# Group by question_id and sort by timestamp\r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.800162, "o", "gen_by_qid = defaultdict(list)\r\n\u001b[?2004l\r\u001b[?2004h"]
[39.800166, "o", "> "]
[39.800195, "o", "for event in gen_events:\r\n\u001b[?2004l\r"]
[39.80021, "o", "\u001b[?2004h> "]
[39.800269, "o", "    gen_by_qid[event['question_id']].append(event)\r\n\u001b[?2004l\r"]
[39.800288, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.800321, "o", "judge_by_qid = defaultdict(list)\r\n\u001b[?2004l\r"]
[39.800333, "o", "\u001b[?2004h> "]
[39.800364, "o", "for event in judge_events:\r\n\u001b[?2004l\r\u001b[?2004h"]
[39.800377, "o", "> "]
[39.800462, "o", "    judge_by_qid[event['question_id']].append(event)\r\n\u001b[?2004l\r"]
[39.800491, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.800497, "o", "# Sort each question's events by timestamp\r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.800624, "o", "for qid in gen_by_qid:\r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.800639, "o", "    gen_by_qid[qid].sort(key=lambda x: x['timestamp'])\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> for qid in judge_by_qid:\r\n\u001b[?2004l\r\u001b[?2004h"]
[39.800643, "o", "> "]
[39.800702, "o", "    judge_by_qid[qid].sort(key=lambda x: x['timestamp'])"]
[39.800767, "o", "\r\n\u001b[?2004l\r\u001b[?2004h"]
[39.800825, "o", "> \r\n\u001b[?2004l\r\u001b[?2004h"]
[39.800923, "o", "> # Assign to runs (earliest=run1, middle=run2, latest=run3)"]
[39.800998, "o", "\r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.801139, "o", "runs = {1: {'generator': [], 'judge': []}, 2: {'generator': [], 'judge': []}, 3: {'generator': [], 'judge': []}}"]
[39.801194, "o", "\r\n"]
[39.801236, "o", "\u001b[?2004l\r"]
[39.801286, "o", "\u001b[?2004h"]
[39.801351, "o", "> "]
[39.801433, "o", "\r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.801489, "o", "for qid in gen_by_qid:"]
[39.801506, "o", "\r\n"]
[39.801519, "o", "\u001b[?2004l\r\u001b[?2004h"]
[39.801577, "o", ">     events = gen_by_qid[qid]"]
[39.801635, "o", "\r\n\u001b[?2004l\r\u001b[?2004h"]
[39.801829, "o", ">     runs[1]['generator'].append(events[0])\r\n\u001b[?2004l\r\u001b[?2004h>     runs[2]['generator'].append(events[1])"]
[39.801877, "o", "\r\n"]
[39.801894, "o", "\u001b[?2004l\r"]
[39.801914, "o", "\u001b[?2004h"]
[39.801949, "o", "> "]
[39.802057, "o", "    runs[3]['generator'].append(events[2])"]
[39.802065, "o", "\r\n"]
[39.802086, "o", "\u001b[?2004l\r"]
[39.802116, "o", "\u001b[?2004h"]
[39.80222, "o", "> \r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.802249, "o", "for qid in judge_by_qid:"]
[39.80229, "o", "\r\n"]
[39.802319, "o", "\u001b[?2004l\r"]
[39.802416, "o", "\u001b[?2004h>     events = judge_by_qid[qid]"]
[39.802446, "o", "\r\n"]
[39.802487, "o", "\u001b[?2004l\r\u001b[?2004h"]
[39.802569, "o", ">     runs[1]['judge'].append(events[0])"]
[39.803268, "o", "\r\n\u001b[?2004l\r\u001b[?2004h>     runs[2]['judge'].append(events[1])\r\n\u001b[?2004l\r\u001b[?2004h>     runs[3]['judge'].append(events[2])\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> # Sort each run by timestamp and write to files\r\n\u001b[?2004l\r\u001b[?2004h> for run_id in [1, 2, 3]:\r\n\u001b[?2004l\r\u001b[?2004h>     runs[run_id]['generator'].sort(key=lambda x: x['timestamp'])\r\n\u001b[?2004l\r\u001b[?2004h>     runs[run_id]['judge'].sort(key=lambda x: x['timestamp'])\r\n\u001b[?2004l\r\u001b[?2004h>     \r\n\u001b[?2004l\r\u001b[?2004h>     with open(f'/app/recovered_logs/run_{run_id}_generator.jsonl', 'w') as f:\r\n\u001b[?2004l\r\u001b[?2004h>         for event in runs[run_id]['generator']:\r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.803284, "o", "            f.write(json.dumps({'timestamp': event['timestamp'], 'question_id': event['question_id'], 'prediction': event['prediction']}, separators=(',', ':')) + '\\n')\r\n\u001b[?2004l\r\u001b[?2004h>     \r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.803345, "o", "    with open(f'/app/recovered_logs/run_{run_id}_judge.jsonl', 'w') as f:\r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.803371, "o", "        for event in runs[run_id]['judge']:\r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.803479, "o", "            f.write(json.dumps({'timestamp': event['timestamp'], 'question_id': event['question_id'], 'target': event['target']}, separators=(',', ':')) + '\\n')"]
[39.803683, "o", "\r\n\u001b[?2004l\r\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> # Check if value is an error\r\n\u001b[?2004l\r\u001b[?2004h> def is_error(value):\r\n\u001b[?2004l\r\u001b[?2004h>     value_lower = value.lower()\r\n\u001b[?2004l\r\u001b[?2004h>     return 'quota exceeds' in value_lower or 'api error' in value_lower or 'timeout' in value_lower"]
[39.803694, "o", "\r\n"]
[39.803731, "o", "\u001b[?2004l\r"]
[39.803738, "o", "\u001b[?2004h> \r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.803758, "o", "# Compute accuracy for each run"]
[39.803771, "o", "\r\n"]
[39.803778, "o", "\u001b[?2004l\r"]
[39.803791, "o", "\u001b[?2004h"]
[39.803801, "o", "> "]
[39.803821, "o", "results = []"]
[39.80383, "o", "\r\n"]
[39.803871, "o", "\u001b[?2004l\r"]
[39.80391, "o", "\u001b[?2004h> for run_id in [1, 2, 3]:"]
[39.803927, "o", "\r\n"]
[39.80395, "o", "\u001b[?2004l\r"]
[39.803963, "o", "\u001b[?2004h"]
[39.804049, "o", "> "]
[39.804057, "o", "    gen_map = {e['question_id']: e['prediction'] for e in runs[run_id]['generator']}"]
[39.804712, "o", "\r\n\u001b[?2004l\r\u001b[?2004h>     judge_map = {e['question_id']: e['target'] for e in runs[run_id]['judge']}\r\n\u001b[?2004l\r\u001b[?2004h>     \r\n\u001b[?2004l\r\u001b[?2004h>     correct = 0\r\n\u001b[?2004l\r\u001b[?2004h>     total = 0\r\n\u001b[?2004l\r\u001b[?2004h>     \r\n\u001b[?2004l\r\u001b[?2004h>     for qid in gen_map:\r\n\u001b[?2004l\r\u001b[?2004h>         if qid in judge_map:\r\n\u001b[?2004l\r\u001b[?2004h>             pred = gen_map[qid]\r\n\u001b[?2004l\r\u001b[?2004h>             tgt = judge_map[qid]\r\n\u001b[?2004l\r\u001b[?2004h>             \r\n\u001b[?2004l\r\u001b[?2004h>             # Skip if either is an error\r\n\u001b[?2004l\r\u001b[?2004h>             if is_error(pred) or is_error(tgt):\r\n\u001b[?2004l\r\u001b[?2004h>                 continue\r\n\u001b[?2004l\r\u001b[?2004h>             \r\n\u001b[?2004l\r\u001b[?2004h>             total += 1\r\n\u001b[?2004l\r\u001b[?2004h>             if pred == tgt:\r\n\u001b[?2004l\r\u001b[?2004h>                 correct += 1\r\n\u001b[?2004l\r\u001b[?2004h>     \r\n\u001b[?2004l\r\u001b[?2004h>     if total == 0:\r\n\u001b[?2004l\r\u001b[?2004h>         accuracy = None\r\n\u001b[?2004l\r\u001b[?2004h>     else:\r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.804802, "o", "        # Round half up to 2 decimals\r\n\u001b[?2004l\r\u001b[?2004h>         acc_decimal = Decimal(correct) / Decimal(total)\r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.804893, "o", "        accuracy = float(acc_decimal.quantize(Decimal('0.01'), rounding=ROUND_HALF_UP))\r\n\u001b[?2004l\r\u001b[?2004h>     \r\n\u001b[?2004l\r"]
[39.804946, "o", "\u001b[?2004h>     results.append({\r\n\u001b[?2004l\r\u001b[?2004h"]
[39.804957, "o", ">         'run_index': run_id,\r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.805012, "o", "        'correct': correct,\r\n\u001b[?2004l\r"]
[39.805025, "o", "\u001b[?2004h>         'total': total,\r\n\u001b[?2004l\r"]
[39.805045, "o", "\u001b[?2004h> "]
[39.805083, "o", "        'accuracy': accuracy\r\n\u001b[?2004l\r\u001b[?2004h>     })\r\n\u001b[?2004l\r\u001b[?2004h"]
[39.805155, "o", "> \r\n\u001b[?2004l\r"]
[39.805164, "o", "\u001b[?2004h> # Write results\r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.805208, "o", "with open('/app/recovered_logs/results.json', 'w') as f:\r\n\u001b[?2004l\r\u001b[?2004h> "]
[39.805219, "o", "    json.dump({'runs': results}, f)"]
[39.805243, "o", "\r\n\u001b[?2004l\r"]
[39.80526, "o", "\u001b[?2004h> "]
[39.805276, "o", "\r\n\u001b[?2004l\r"]
[39.805279, "o", "\u001b[?2004h"]
[39.805307, "o", "> "]
[39.805311, "o", "EOF; tmux wait -S done"]
[39.805317, "o", "\r\n"]
[39.805351, "o", "\u001b[?2004l\r"]
[39.805384, "o", "\u001b[?2004h> "]
[228.217505, "i", "\u0004"]
[228.217899, "o", "\u001b[?2004l\r\r\nbash: warning: here-document at line 3 delimited by end-of-file (wanted `EOF')\r\n"]
[228.227492, "o", "  File \u001b[35m\"<stdin>\"\u001b[0m, line \u001b[35m102\u001b[0m\r\n    EOF; tmux \u001b[1;31mwait\u001b[0m -S done\r\n              \u001b[1;31m^^^^\u001b[0m\r\n\u001b[1;35mSyntaxError\u001b[0m: \u001b[35minvalid syntax\u001b[0m\r\n"]
[228.229405, "o", "\u001b[?2004hroot@7aa0ba912b35:/app# "]
