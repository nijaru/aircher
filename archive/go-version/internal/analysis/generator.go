package analysis

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/rs/zerolog"
)

// DocumentationGenerator generates project analysis documentation
type DocumentationGenerator struct {
	projectRoot string
	logger      zerolog.Logger
}

// NewDocumentationGenerator creates a new documentation generator
func NewDocumentationGenerator(projectRoot string, logger zerolog.Logger) *DocumentationGenerator {
	return &DocumentationGenerator{
		projectRoot: projectRoot,
		logger:      logger.With().Str("component", "doc_generator").Logger(),
	}
}

// GenerateProjectAnalysis creates the project_analysis.md file
func (dg *DocumentationGenerator) GenerateProjectAnalysis(result *AnalysisResult) error {
	dg.logger.Info().Msg("Generating project analysis documentation")

	content := dg.buildAnalysisContent(result)

	// Ensure .aircher directory exists
	aircherDir := filepath.Join(dg.projectRoot, ".aircher")
	if err := os.MkdirAll(aircherDir, 0755); err != nil {
		return fmt.Errorf("failed to create .aircher directory: %w", err)
	}

	// Write the analysis file
	analysisPath := filepath.Join(aircherDir, "project_analysis.md")
	if err := os.WriteFile(analysisPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write project analysis: %w", err)
	}

	dg.logger.Info().Str("file", analysisPath).Msg("Project analysis documentation generated")
	return nil
}

// buildAnalysisContent builds the markdown content for project analysis
func (dg *DocumentationGenerator) buildAnalysisContent(result *AnalysisResult) string {
	var sb strings.Builder

	projectName := dg.getProjectName(result)
	
	// Header
	sb.WriteString(fmt.Sprintf("# Project Analysis - %s\n\n", projectName))
	sb.WriteString("*This file is automatically generated by aircher and should not be manually edited.*\n\n")
	sb.WriteString(fmt.Sprintf("**Last Updated:** %s\n\n", result.AnalyzedAt.Format("2006-01-02 15:04:05")))

	// Table of Contents
	sb.WriteString("## Table of Contents\n\n")
	sb.WriteString("- [Project Overview](#project-overview)\n")
	sb.WriteString("- [Project Structure](#project-structure)\n")
	sb.WriteString("- [Documentation Files](#documentation-files)\n")
	sb.WriteString("- [Technology Stack](#technology-stack)\n")
	sb.WriteString("- [Architecture Patterns](#architecture-patterns)\n")
	sb.WriteString("- [Build Systems](#build-systems)\n")
	sb.WriteString("- [Project Metadata](#project-metadata)\n\n")

	// Project Overview
	sb.WriteString("## Project Overview\n\n")
	sb.WriteString(dg.buildProjectOverview(result))

	// Project Structure
	sb.WriteString("## Project Structure\n\n")
	sb.WriteString(dg.buildProjectStructure(result))

	// Documentation Files
	sb.WriteString("## Documentation Files\n\n")
	sb.WriteString(dg.buildDocumentationSection(result.Documentation))

	// Technology Stack
	sb.WriteString("## Technology Stack\n\n")
	sb.WriteString(dg.buildTechnologyStack(result.Components))

	// Architecture Patterns  
	sb.WriteString("## Architecture Patterns\n\n")
	sb.WriteString(dg.buildArchitecturePatterns(result.Components))

	// Build Systems
	sb.WriteString("## Build Systems\n\n")
	sb.WriteString(dg.buildBuildSystems(result.Components))

	// Project Metadata
	sb.WriteString("## Project Metadata\n\n")
	sb.WriteString(dg.buildProjectMetadata(result.Metadata))

	// Footer
	sb.WriteString("\n---\n\n")
	sb.WriteString("*Generated by aircher project analyzer*\n")

	return sb.String()
}

// getProjectName extracts the project name from metadata or uses directory name
func (dg *DocumentationGenerator) getProjectName(result *AnalysisResult) string {
	// Look for project name in metadata
	for _, meta := range result.Metadata {
		if meta.Key == "project_name" || meta.Key == "name" {
			return meta.Value
		}
	}

	// Fallback to directory name
	return filepath.Base(dg.projectRoot)
}

// buildProjectOverview builds the project overview section
func (dg *DocumentationGenerator) buildProjectOverview(result *AnalysisResult) string {
	var sb strings.Builder

	// Find language
	var primaryLanguage string
	var frameworks []string
	
	for _, component := range result.Components {
		if component.Type == "language" && component.Confidence > 0.8 {
			primaryLanguage = component.Component
			break
		}
	}

	for _, component := range result.Components {
		if component.Type == "framework" && component.Confidence > 0.7 {
			frameworks = append(frameworks, component.Component)
		}
	}

	if primaryLanguage != "" {
		sb.WriteString(fmt.Sprintf("This is a **%s** project", strings.Title(primaryLanguage)))
		if len(frameworks) > 0 {
			sb.WriteString(fmt.Sprintf(" using %s", strings.Join(frameworks, ", ")))
		}
		sb.WriteString(".\n\n")
	}

	// Documentation summary
	if len(result.Documentation) > 0 {
		sb.WriteString(fmt.Sprintf("The project contains **%d documentation files** covering various aspects of the system.\n\n", len(result.Documentation)))
	}

	// Components summary
	langCount := dg.countComponentsByType(result.Components, "language")
	frameworkCount := dg.countComponentsByType(result.Components, "framework") 
	buildCount := dg.countComponentsByType(result.Components, "build")
	archCount := dg.countComponentsByType(result.Components, "architecture")

	sb.WriteString("### Component Summary\n\n")
	sb.WriteString(fmt.Sprintf("- **Languages:** %d detected\n", langCount))
	sb.WriteString(fmt.Sprintf("- **Frameworks:** %d detected\n", frameworkCount))
	sb.WriteString(fmt.Sprintf("- **Build Systems:** %d detected\n", buildCount))
	sb.WriteString(fmt.Sprintf("- **Architecture Patterns:** %d detected\n\n", archCount))

	return sb.String()
}

// buildProjectStructure builds the project structure section
func (dg *DocumentationGenerator) buildProjectStructure(result *AnalysisResult) string {
	var sb strings.Builder

	// Get top-level directories
	entries, err := os.ReadDir(dg.projectRoot)
	if err != nil {
		sb.WriteString("*Unable to read project structure*\n\n")
		return sb.String()
	}

	sb.WriteString("### Top-Level Structure\n\n")
	sb.WriteString("```\n")
	sb.WriteString(fmt.Sprintf("%s/\n", filepath.Base(dg.projectRoot)))

	for _, entry := range entries {
		if entry.IsDir() {
			sb.WriteString(fmt.Sprintf("├── %s/\n", entry.Name()))
		} else {
			sb.WriteString(fmt.Sprintf("├── %s\n", entry.Name()))
		}
	}
	sb.WriteString("```\n\n")

	return sb.String()
}

// buildDocumentationSection builds the documentation files section
func (dg *DocumentationGenerator) buildDocumentationSection(docs []DocumentationFile) string {
	var sb strings.Builder

	if len(docs) == 0 {
		sb.WriteString("No documentation files detected.\n\n")
		return sb.String()
	}

	// Group by type
	docTypes := make(map[string][]DocumentationFile)
	for _, doc := range docs {
		docTypes[doc.DocType] = append(docTypes[doc.DocType], doc)
	}

	for docType, typeDocs := range docTypes {
		sb.WriteString(fmt.Sprintf("### %s Files\n\n", strings.Title(docType)))
		
		for _, doc := range typeDocs {
			sb.WriteString(fmt.Sprintf("**%s** (`%s`)\n", doc.Title, doc.FilePath))
			if doc.Purpose != "" {
				sb.WriteString(fmt.Sprintf("- *Purpose:* %s\n", doc.Purpose))
			}
			if len(doc.Sections) > 0 {
				sb.WriteString(fmt.Sprintf("- *Sections:* %d headings\n", len(doc.Sections)))
			}
			if len(doc.CrossRefs) > 0 {
				sb.WriteString(fmt.Sprintf("- *References:* %s\n", strings.Join(doc.CrossRefs, ", ")))
			}
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

// buildTechnologyStack builds the technology stack section
func (dg *DocumentationGenerator) buildTechnologyStack(components []ProjectComponent) string {
	var sb strings.Builder

	languages := dg.filterComponentsByType(components, "language")
	frameworks := dg.filterComponentsByType(components, "framework")

	if len(languages) == 0 && len(frameworks) == 0 {
		sb.WriteString("No specific technology stack detected.\n\n")
		return sb.String()
	}

	if len(languages) > 0 {
		sb.WriteString("### Programming Languages\n\n")
		for _, lang := range languages {
			confidence := fmt.Sprintf("%.0f%%", lang.Confidence*100)
			sb.WriteString(fmt.Sprintf("- **%s** (%s confidence)\n", strings.Title(lang.Component), confidence))
			sb.WriteString(fmt.Sprintf("  - %s\n", lang.Description))
			if len(lang.Evidence) > 0 {
				sb.WriteString(fmt.Sprintf("  - *Evidence:* %s\n", strings.Join(lang.Evidence, ", ")))
			}
			sb.WriteString("\n")
		}
	}

	if len(frameworks) > 0 {
		sb.WriteString("### Frameworks and Libraries\n\n")
		for _, framework := range frameworks {
			confidence := fmt.Sprintf("%.0f%%", framework.Confidence*100)
			sb.WriteString(fmt.Sprintf("- **%s** (%s confidence)\n", strings.Title(framework.Component), confidence))
			sb.WriteString(fmt.Sprintf("  - %s\n", framework.Description))
			if len(framework.Evidence) > 0 {
				sb.WriteString(fmt.Sprintf("  - *Evidence:* %s\n", strings.Join(framework.Evidence, ", ")))
			}
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

// buildArchitecturePatterns builds the architecture patterns section
func (dg *DocumentationGenerator) buildArchitecturePatterns(components []ProjectComponent) string {
	var sb strings.Builder

	archComponents := dg.filterComponentsByType(components, "architecture")

	if len(archComponents) == 0 {
		sb.WriteString("No specific architecture patterns detected.\n\n")
		return sb.String()
	}

	for _, arch := range archComponents {
		confidence := fmt.Sprintf("%.0f%%", arch.Confidence*100)
		sb.WriteString(fmt.Sprintf("### %s (%s confidence)\n\n", strings.Title(strings.Replace(arch.Component, "_", " ", -1)), confidence))
		sb.WriteString(fmt.Sprintf("%s\n\n", arch.Description))
		
		if len(arch.Evidence) > 0 {
			sb.WriteString("**Evidence:**\n")
			for _, evidence := range arch.Evidence {
				sb.WriteString(fmt.Sprintf("- %s\n", evidence))
			}
			sb.WriteString("\n")
		}
	}

	return sb.String()
}

// buildBuildSystems builds the build systems section
func (dg *DocumentationGenerator) buildBuildSystems(components []ProjectComponent) string {
	var sb strings.Builder

	buildComponents := dg.filterComponentsByType(components, "build")

	if len(buildComponents) == 0 {
		sb.WriteString("No build systems detected.\n\n")
		return sb.String()
	}

	for _, build := range buildComponents {
		confidence := fmt.Sprintf("%.0f%%", build.Confidence*100)
		sb.WriteString(fmt.Sprintf("- **%s** (%s confidence)\n", strings.Title(strings.Replace(build.Component, "_", " ", -1)), confidence))
		sb.WriteString(fmt.Sprintf("  - %s\n", build.Description))
		if len(build.Evidence) > 0 {
			sb.WriteString(fmt.Sprintf("  - *Files:* %s\n", strings.Join(build.Evidence, ", ")))
		}
		sb.WriteString("\n")
	}

	return sb.String()
}

// buildProjectMetadata builds the project metadata section
func (dg *DocumentationGenerator) buildProjectMetadata(metadata []ProjectMetadata) string {
	var sb strings.Builder

	if len(metadata) == 0 {
		sb.WriteString("No project metadata extracted.\n\n")
		return sb.String()
	}

	// Group by category
	categories := make(map[string][]ProjectMetadata)
	for _, meta := range metadata {
		categories[meta.Category] = append(categories[meta.Category], meta)
	}

	for category, categoryMeta := range categories {
		sb.WriteString(fmt.Sprintf("### %s\n\n", strings.Title(category)))
		
		for _, meta := range categoryMeta {
			confidence := fmt.Sprintf("%.0f%%", meta.Confidence*100)
			sb.WriteString(fmt.Sprintf("- **%s:** %s (%s confidence)\n", strings.Title(strings.Replace(meta.Key, "_", " ", -1)), meta.Value, confidence))
			if meta.Source != "" {
				sb.WriteString(fmt.Sprintf("  - *Source:* %s\n", meta.Source))
			}
		}
		sb.WriteString("\n")
	}

	return sb.String()
}

// Helper functions

func (dg *DocumentationGenerator) filterComponentsByType(components []ProjectComponent, componentType string) []ProjectComponent {
	var filtered []ProjectComponent
	for _, comp := range components {
		if comp.Type == componentType {
			filtered = append(filtered, comp)
		}
	}
	return filtered
}

func (dg *DocumentationGenerator) countComponentsByType(components []ProjectComponent, componentType string) int {
	count := 0
	for _, comp := range components {
		if comp.Type == componentType {
			count++
		}
	}
	return count
}