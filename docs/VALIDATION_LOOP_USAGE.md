# Validation Loop Usage Guide

**Purpose**: AutoGen-style validation loop to fix SWE-bench location identification failures

**Problem Solved**: Original approach (0/2 success rate) failed because agent targeted wrong locations despite understanding the problem correctly.

**Solution**: Multi-agent validation with Explorer (find/verify) and Builder (generate) roles.

## How It Works

```
User: "Fix bug"
  ↓
Phase 1: Explorer finds 1-3 location candidates (ranked by confidence)
  ↓
Phase 2: For each candidate (max 3 attempts):
  ├─ Builder generates patch for location
  ├─ Explorer verifies "Does this file/line contain expected code?"
  ├─ If YES: Return validated patch ✓
  └─ If NO: Try next candidate
  ↓
Result: Validated patch or failure after 3 attempts
```

## Core Data Structures

### LocationCandidate
Represents a potential bug location found by Explorer agent:

```rust
use aircher::agent::LocationCandidate;
use std::path::PathBuf;

let candidate = LocationCandidate {
    file_path: PathBuf::from("src/auth.rs"),
    line_number: Some(42),
    confidence: 0.95,  // 0.0 to 1.0
    reasoning: "Variable name matches bug description".to_string(),
};
```

### PatchProposal
Patch generated by Builder agent for a specific location:

```rust
use aircher::agent::PatchProposal;

let proposal = PatchProposal {
    location: candidate,
    patch: "--- a/src/auth.rs\n+++ b/src/auth.rs\n...".to_string(),
    reasoning: "Fix token validation".to_string(),
};
```

### VerificationResult
Explorer's verification of whether patch targets correct location:

```rust
use aircher::agent::VerificationResult;

let verification = VerificationResult {
    is_correct: false,
    reasoning: "File doesn't contain expected variable".to_string(),
    issues: vec![
        "Variable X not found".to_string(),
        "Line is in documentation, not implementation".to_string(),
    ],
};
```

### ValidatedPatch
Successfully verified patch after validation loop:

```rust
use aircher::agent::ValidatedPatch;

let validated = ValidatedPatch {
    patch: "unified diff...".to_string(),
    location: candidate,
    attempts: 2,  // Took 2 attempts to find correct location
};
```

## Agent Methods

### 1. find_bug_locations() - Explorer Role

Finds 1-3 candidate locations ranked by confidence:

```rust
use aircher::agent::Agent;
use aircher::providers::LLMProvider;

let candidates = agent.find_bug_locations(
    "Token validation missing",           // Bug description
    Path::new("/tmp/repository"),          // Repository path
    &provider as &dyn LLMProvider,         // LLM provider
    "claude-sonnet-4.5",                   // Model name
).await?;

// Returns Vec<LocationCandidate> sorted by confidence (highest first)
```

**Prompt Strategy**:
- Explicit navigation steps: "Use grep", "Use read_file", "Identify EXACT location"
- Structured JSON output
- Handles markdown code blocks

### 2. verify_patch_location() - Explorer Role

Verifies proposed patch targets the correct location:

```rust
let verification = agent.verify_patch_location(
    &proposal,                             // PatchProposal from generate_patch
    "Token validation missing",           // Original bug description
    &provider as &dyn LLMProvider,
    "claude-sonnet-4.5",
).await?;

if verification.is_correct {
    println!("✓ Location verified!");
} else {
    println!("✗ Verification failed: {}", verification.reasoning);
    for issue in verification.issues {
        println!("  - {}", issue);
    }
}
```

**Verification Steps** (from prompt):
1. Read the target file
2. Check if line contains code mentioned in bug description
3. Verify patch makes sense for this location
4. Confirm this is ACTUAL bug location (not just related code)

### 3. generate_patch() - Builder Role

Generates unified diff patch for verified location:

```rust
let proposal = agent.generate_patch(
    "Token validation missing",           // Bug description
    &candidate,                            // LocationCandidate from find_bug_locations
    &provider as &dyn LLMProvider,
    "claude-sonnet-4.5",
).await?;

println!("Patch: {}", proposal.patch);
println!("Reasoning: {}", proposal.reasoning);
```

## Full Validation Loop Example

```rust
use aircher::agent::{Agent, ValidationLoopCoordinator};
use aircher::providers::LLMProvider;
use std::path::Path;

async fn fix_bug_with_validation(
    agent: &Agent,
    bug_description: &str,
    repository_path: &Path,
    provider: &dyn LLMProvider,
    model: &str,
) -> anyhow::Result<Option<ValidatedPatch>> {
    use aircher::agent::ValidatedPatch;

    // Create coordinator
    let coordinator = ValidationLoopCoordinator::new();  // Default: max 3 attempts
    let max_attempts = coordinator.max_attempts();

    // Phase 1: Find candidates
    let mut candidates = agent.find_bug_locations(
        bug_description,
        repository_path,
        provider,
        model,
    ).await?;

    // Sort by confidence (highest first)
    candidates.sort_by(|a, b| b.confidence.partial_cmp(&a.confidence).unwrap());

    // Phase 2: Validate candidates
    for (attempt, candidate) in candidates.iter().enumerate().take(max_attempts) {
        println!("Attempt {}/{}: Trying {:?} (confidence: {:.1}%)",
                 attempt + 1, max_attempts, candidate.file_path, candidate.confidence * 100.0);

        // Generate patch
        let proposal = agent.generate_patch(
            bug_description,
            candidate,
            provider,
            model,
        ).await?;

        // Verify
        let verification = agent.verify_patch_location(
            &proposal,
            bug_description,
            provider,
            model,
        ).await?;

        if verification.is_correct {
            println!("✓ Location verified on attempt {}", attempt + 1);
            return Ok(Some(ValidatedPatch {
                patch: proposal.patch,
                location: candidate.clone(),
                attempts: attempt + 1,
            }));
        }

        println!("✗ Verification failed: {}", verification.reasoning);
        for issue in &verification.issues {
            println!("  - {}", issue);
        }
    }

    // All attempts exhausted
    Ok(None)
}
```

## SWE-bench Integration

### Task 0: astropy__astropy-12907

**Original Result**: ❌ Wrong location in file (changed loop logic instead of assignment)

**With Validation Loop**:
1. Find candidates: 3 locations in separable.py
2. Attempt 1: Line 180 (loop logic) → Verification FAILS
3. Attempt 2: Line 246 (assignment) → Verification SUCCEEDS ✓
4. Result: Correct patch after 2 attempts

### Task 6: django__django-10914

**Original Result**: ❌ Wrong file entirely (changed __init__.py instead of global_settings.py)

**With Validation Loop**:
1. Find candidates: __init__.py, global_settings.py, settings.py
2. Attempt 1: __init__.py → Verification FAILS ("Setting not defined here")
3. Attempt 2: global_settings.py → Verification SUCCEEDS ✓
4. Result: Correct patch after 2 attempts

## Expected Results

**Target**: Improve from 0/2 (0%) to 1-2/2 (50-100%) success rate

**Minimum Success** (acceptable):
- 1/2 tasks pass (50% improvement)
- Validation catches wrong locations
- Max 3 attempts needed

**Good Success** (target):
- 2/2 tasks pass (100% fix)
- Average 1.5 attempts per task
- Clear verification reasoning

## Prompt Engineering

### Critical Components

**1. Explicit Navigation Steps**:
```
IMPORTANT STEPS:
1. Use grep to search for relevant code patterns
2. Use read_file to examine candidate files
3. Identify EXACT location (file + line number)
4. Verify code matches bug description
```

**2. Verification Requirements**:
```
VERIFICATION STEPS:
1. Read the target file
2. Check if line contains code from bug description
3. Verify patch makes sense for this location
4. Confirm this is ACTUAL bug (not just related code)
```

**3. JSON Output Format**:
- Structured responses for parsing
- Handles markdown code blocks: ` ```json\n...\n``` `
- Clear field names (file_path, line_number, confidence, reasoning)

## Testing

See `tests/validation_loop_integration_test.rs` for comprehensive test suite:

- 10 test cases covering all scenarios
- MockProvider for predictable responses
- Full validation loop simulation
- Multiple attempts and failure cases

```bash
cargo test --test validation_loop_integration_test
```

## Configuration

```rust
// Default: 3 attempts
let coordinator = ValidationLoopCoordinator::new();

// Custom: 5 attempts
let coordinator = ValidationLoopCoordinator::with_max_attempts(5);

// Get max attempts
let max = coordinator.max_attempts();
```

## Error Handling

### All Candidates Fail Verification
```rust
match validated_patch {
    Some(patch) => {
        // Success: Use the validated patch
    }
    None => {
        // Failure: All attempts exhausted
        // Log: "No correct location found in top 3 candidates"
        // User can review and override manually
    }
}
```

### LLM Returns Invalid JSON
- Retry prompt with "fix your JSON" instruction
- Fallback to text parsing if JSON fails
- Log error for debugging

### Tool Execution Fails (grep/read_file)
- Retry with different search terms
- Fallback to semantic search
- Log errors for debugging

## Performance

**Latency**:
- 3 attempts × 2 LLM calls (generate + verify) = 6 LLM calls total
- Worst case: ~60-90s for 3 attempts
- Best case: ~20-30s for 1 attempt (immediate success)

**Token Usage**:
- Find candidates: ~1000 tokens per call
- Generate patch: ~800 tokens per call
- Verify location: ~600 tokens per call
- Total worst case: ~7,200 tokens (3 attempts)

**Improvement**:
- Accept latency for now (validation critical)
- Future: Async validation, caching, optimization

## Future Enhancements

1. **Caching**: Store verified locations for similar bugs
2. **Parallel Verification**: Test multiple candidates concurrently
3. **Confidence Threshold**: Skip low-confidence candidates (<0.3)
4. **Adaptive Attempts**: Increase max attempts if all candidates >0.8 confidence
5. **Cross-Task Learning**: Use episodic memory to avoid duplicate research

## References

- **Data structures**: `src/agent/validation_loop.rs`
- **Agent methods**: `src/agent/core.rs` lines 2195-2515
- **Integration tests**: `tests/validation_loop_integration_test.rs`
- **Research**: `ai/OPTION_B_VALIDATION_LOOP_PLAN.md`
